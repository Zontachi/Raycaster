/* autogenerated by Processing revision 1286 on 2023-10-05 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class RayCaster extends PApplet {

//Raycasting system V1.0
//Made by Pascal Schippers

//Variables
String sMapType = "Medium";
boolean bDrawMap = false, bMouseClicked = false, bDebugMode = false;
int iTimerMin = 0, iTimerMax = 1, iEnemySize = 20, iEnemyCount, iPlayerStartX = 210, iPlayerStartY = 180, iPlayerStartSize = 20, iEnemiesStillAlive;
ArrayList<Enemy> enemies = new ArrayList<Enemy>();
String sDeath = "You died.", sReset = "Press 'R' to reset.", sEnemiesLeft = "Enemies left: ", sWin = "You win!";

//Objects
Map map;
Ray caster = new Ray();
Player P1 = new Player(iPlayerStartX, iPlayerStartY, iPlayerStartSize);

 public void setup(){
  /* size commented out by preprocessor */;
  background(0);
  
  //Create the correct map
  switch(sMapType){
    case "Small":
      println("Creating small map.");
      map = new Map(10, 10, 64, "Small");
      map.mapInitialize();
      break;
    case "Medium":
      println("Creating medium map.");
      map = new Map(20, 20, 32, "Medium");
      map.mapInitialize();
      break;
    case "Large":
      println("Creating large map.");
      map = new Map(40, 40, 16, "Large");
      map.mapInitialize();
      break;
  }
 addEnemies();
}

 public void draw(){
  //Timer to slow down ray traces per second
  iTimerMin++;
  if (iTimerMin > iTimerMax){iTimerMin = 0;}
  
  P1.updatePlayer();
  map.drawMap(0); //Draw an invisible map to hide some visual overlaps
  
  //Flashlight mode for debugging
  if (bDrawMap || bPlayerAlive == false){
    map.drawMap(60); 
    drawEnemies();
  }
  
  if (iTimerMin == iTimerMax){bMouseClicked = false;} //Reset mouse clicked status
  if (iTimerMin == iTimerMax){drawLoS();} //Slowed down LoS checks for enemies
  
  drawText();
}

 public void drawText(){
  textSize(20); fill(255, 0, 0); text(sEnemiesLeft + iEnemiesStillAlive, 480, 23); //Text to show how many enemies are still alive
  
  if (iEnemiesStillAlive < 4){
    textSize(20); fill(255, 0, 0); text("Radar Active", 50, 23); //Text to show that the radar is active
  }
  
  if (bPlayerAlive == false){ //Draw death screen
    textSize(128); fill(255, 0, 0); text(sDeath, 80, 260);
    textSize(20); fill(255, 0, 0); text(sReset, 240, 330);
  }
  
  if (iEnemiesStillAlive == 0){ //Draw win screen
    textSize(128); fill(0, 255, 0); text(sWin, 90, 260);
    textSize(20); fill(0, 255, 0); text(sReset, 240, 330);
  }
}

 public void drawLoS(){ //Call line of sight calculations for all enemies
  for (int ii = 0; ii < iEnemyCount; ii++){
    Enemy currentEnemy = enemies.get(ii);
    currentEnemy.checkLoS();
  }
}

 public void addEnemies(){ //Add enemies to the game based on map type
  switch (sMapType){
    case "Small":
      break;
    case "Medium":
      //Add enemies to the game
      addEnemy(2, 1);
      addEnemy(4, 1);
      addEnemy(15, 1);
      addEnemy(7, 3);
      addEnemy(18, 4);
      addEnemy(9, 5);
      addEnemy(2, 10);
      addEnemy(16, 8);
      addEnemy(15, 11);
      addEnemy(13, 14);
      addEnemy(17, 18);
      addEnemy(1, 18);
      addEnemy(8, 17);
      addEnemy(11, 15);
      addEnemy(17, 9);
      iEnemyCount = enemies.size();
      iEnemiesStillAlive = iEnemyCount;
      println(iEnemyCount + " enemies have been created.");
      break;
    case "Large":
      break;
  }
}

 public void addEnemy(int x, int y){ //Add a single new enemy on a certain point on the map
  x = x * iTileSize + iTileSize/2;
  y = y * iTileSize + iTileSize/2;
  enemies.add(new Enemy(x, y, iEnemySize));
}

 public void drawEnemies(){ //Draw visible enemies in case of flashlight mode
  for (int ii = 0; ii < iEnemyCount; ii++){
    Enemy currentEnemy = enemies.get(ii);
    currentEnemy.drawEnemy();
  }
}

 public void gameReset(){
  for (int ii = 0; ii < iEnemyCount; ii++){
    Enemy currentEnemy = enemies.get(ii);
    currentEnemy.bAlive = true;
  }
  iEnemiesStillAlive = iEnemyCount;
  fPlayerX = iPlayerStartX;
  fPlayerY = iPlayerStartY;
  bPlayerAlive = true;
}

public float viewAngle(float fAX, float fAY, float fBX, float fBY){ //Calculates the angle between 2 points in a circle
  float fAngle = atan2(fBY - fAY, fBX - fAX);
  return fAngle;
}
  
public float distanceToWall(float fAX, float fAY, float fBX, float fBY){ //Calculates the distance of a line between 2 points using pythagoras
  return sqrt((fBX - fAX) * (fBX - fAX) + (fBY - fAY) * (fBY - fAY));
}

 public void keyPressed(){ //Change values based on keys pressed
  if (key == 'w' || key == 'W'){iMoveY = -1;}
  if (key == 'a' || key == 'A'){iMoveX = -1;}
  if (key == 's' || key == 'S'){iMoveY =  1;}
  if (key == 'd' || key == 'D'){iMoveX =  1;}
  if ((key == 'f' || key == 'F') && bDebugMode){bDrawMap = true;}
  if (key == 'r' || key == 'R'){gameReset();}
}
  
 public void keyReleased(){ //Change values based on keys released
  if (key == 'w' || key == 'W'){iMoveY = 0;}
  if (key == 'a' || key == 'A'){iMoveX = 0;}
  if (key == 's' || key == 'S'){iMoveY = 0;}
  if (key == 'd' || key == 'D'){iMoveX = 0;}
  if ((key == 'f' || key == 'F') && bDebugMode){bDrawMap = false;}
}

 public void mouseClicked(){ //Check for mouse left clicks
  bMouseClicked = true;
}
class Enemy{
  //Variables
  int iEnemyX, iEnemyY, iEnemySize, iEnemyR;
  boolean bVulnerable = false, bAlive = true;
  
  Enemy(int x, int y, int size){
    iEnemyX = x;
    iEnemyY = y; 
    iEnemySize = size; //Diameter
    iEnemyR = size/2; //Radius
  }
  
   public void checkVisibility(float a, float b ,float c){ //Check whether a line touches, intersects or does not collide with the enemy
    float fDist = abs(a * iEnemyX + b * iEnemyY + c) / sqrt(a * a + b * b);
    if (iEnemyR == fDist){println("Touch");}
    if (iEnemyR > fDist){println("Intersect");}
    if (iEnemyR < fDist){println("Nope");}
  }
  
   public boolean checkPixel(float x, float y){ //Check for overlapping areas between a line this enemy
    float fCP  = pow(x - iEnemyX, 2) + pow(y - iEnemyY, 2);
    if (fCP == pow(iEnemyR, 2)){return true;}
    if (fCP < pow(iEnemyR, 2)){return true;}
    return false;
  }
  
   public float checkDiscriminant(float A, float B, float C){ //Calculate the discriminant to check the amount of intersections
    float fDelta = (B*B) - 4 * A * C;
    if (fDelta == 0) {return 1;}
    if (fDelta < 0) {return 0;}
    if (fDelta > 0) {return 2;}
    println("Error");
    return 0;
  }
  
   public void checkLoS(){ //Draw a ray from the enemy to the player
    if (bAlive){
      float fAngleToPlayer = viewAngle(iEnemyX, iEnemyY, fPlayerX, fPlayerY);
      caster.drawRays(1, 1, iEnemyX, iEnemyY, fAngleToPlayer, 0, "Red", 1, false);
    }
  }
  
   public void checkDeath(){ //Check whether this instance of enemy should get killed or not
    for (int ii = 0; ii < iEnemyCount; ii++){
      Enemy currentEnemy = enemies.get(ii);
      if (currentEnemy.bVulnerable == true && bMouseClicked == true){currentEnemy.bAlive = false; iEnemiesStillAlive--;}
    }
  }
  
   public void drawEnemy(){ //Draw the enemy
    if (bAlive){
      fill(125, 0, 0);
      strokeWeight(1);
      stroke(125, 0, 0);
      circle(iEnemyX, iEnemyY, iEnemySize);
    }
  }
}
//Public variables
public int iMapSizeX, iMapSizeY, iTileSize, iBitShift = 6;

//Map layouts
int[] mapCurrentLayout;
int[] mapLayoutSmall = {
    1,1,1,1,1,1,1,1,1,1,
    1,0,0,1,0,0,0,0,0,1,
    1,0,0,1,0,0,0,1,1,1,
    1,0,0,1,0,0,0,1,0,1,
    1,0,0,1,0,0,1,1,0,1,
    1,0,0,0,0,0,0,0,0,1,
    1,0,0,0,0,0,0,0,0,1,
    1,0,1,0,0,0,1,1,1,1,
    1,0,0,0,0,0,0,0,0,1,
    1,1,1,1,1,1,1,1,1,1 
  };
int[] mapLayoutMedium = {
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,0,0,1,0,0,0,1,0,1,0,0,0,0,1,0,0,1,0,1,
    1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,0,1,0,0,1,0,1,1,1,0,0,1,1,1,1,0,1,1,
    1,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1,
    1,0,0,1,0,0,0,1,0,0,1,0,1,1,0,0,1,0,0,1,
    1,0,0,0,0,0,1,0,0,0,0,0,1,1,0,0,1,1,0,1,
    1,0,1,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,1,
    1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,1,1,1,
    1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,1,
    1,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,
    1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,
    1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1,
    1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,
    1,0,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,
    1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,
    1,0,0,0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,
    1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  };
int[] mapLayoutLarge = {
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,
    1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  };  

class Map{
  Map(int x, int y, int s, String str){
    iMapSizeX = x;
    iMapSizeY = y;
    iTileSize = s;
    sMapType = str;
  }
  
   public void mapInitialize(){ //Load the correct map
    switch(sMapType){
      case "Small":
        println("Loading small map.");
        mapCurrentLayout = mapLayoutSmall;
        iBitShift = 6;
        break;
      case "Medium":
        println("Loading medium map.");
        mapCurrentLayout = mapLayoutMedium;
        iBitShift = 5;
        break;
      case "Large":
        println("Loading large map.");
        mapCurrentLayout = mapLayoutLarge;
        iBitShift = 4;
        break;
    }
  }
  
   public void drawMap(int iC){ //Draw the tileset
    fill(iC);
    stroke(0);
    strokeWeight(5);
    for (int yy = 0; yy < iMapSizeX; yy++){
      for (int xx = 0; xx < iMapSizeY; xx++){
        if (mapCurrentLayout[yy*iMapSizeX+xx] == 1)
        rect(xx * iTileSize, yy * iTileSize, iTileSize, iTileSize);
      }
    }
  }
}
//Public variables
public int iMoveX, iMoveY;
public float fPlayerX, fPlayerY;
public boolean bPlayerAlive = true;

class Player{
  //Variables
  int iPlayerCornerX, iPlayerCornerX2, iPlayerCornerY, iPlayerCornerY2, iPlayerR;
  int fLX, fLX2, fLX3, fLX4, fLY, fLY2, fLY3, fLY4;
  int iPlayerSize, iSpeedX = 2, iSpeedY = 2;
  float fPlayerDX, fPlayerDY, fPlayerAngle;
  
  Player(int x, int y, int size){
    fPlayerX = x;
    fPlayerY = y; 
    iPlayerSize = size;
    iPlayerR = size/2;
  }

   public void updatePlayer(){
    if (bPlayerAlive){ //Only allow actions when the player is alive
      playerMovement();
      rotatePlayer();
      if (iTimerMin == iTimerMax){
        background(0);
        caster.drawRays(60, 6, fPlayerX, fPlayerY, fPlayerAngle, 1, "White", 4, false); //Draw white player vision rays with 1 bounce
        caster.drawRays(1, 1, fPlayerX, fPlayerY, viewAngle(fPlayerX, fPlayerY, mouseX, mouseY), 1, "LightGreen" , 3, true); //Draw a single ray to indicate where the player is looking
      }
    }
    drawPlayer();
    remainingEnemies();
  }
  
   public boolean checkPixel(float x, float y){ //Check for overlapping areas between a line and the player
    float fCP  = pow(x - fPlayerX, 2) + pow(y - fPlayerY, 2);
    if (fCP == pow(iPlayerR, 2)){return true;}
    if (fCP < pow(iPlayerR, 2)){return true;}
    return false;
  }
  
   public void remainingEnemies(){ //Draw rays to the remaining enemies to help with the last few kills
    for (int ii = 0; ii < iEnemyCount; ii++){
      Enemy currentEnemy = enemies.get(ii);
      if (currentEnemy.bAlive == true){
        float fAngleToEnemy = viewAngle(fPlayerX, fPlayerY, currentEnemy.iEnemyX, currentEnemy.iEnemyY);
        caster.drawRays(1, 1, fPlayerX, fPlayerY, fAngleToEnemy, 0, "LightRed", 2, false);
      }
    }
  }
  
   public void rotatePlayer(){ //Rotate the player angle towards the cursor
   fPlayerAngle = viewAngle(fPlayerX, fPlayerY, mouseX, mouseY) + (f1DgrRad * 30);
  }

   public void drawPlayer(){ //Draw the player
    fill(125, 255, 0);
    strokeWeight(1);
    stroke(125, 255, 0);
    circle(fPlayerX, fPlayerY, iPlayerSize);
  }
  
   public void playerMovement(){ //Collision checks between the player and the map walls
    collisionCalc(); //Update the player corner location for hitbox calculations
    
    //Handle movement collisions to the left
    leftMovement(fLX);
    leftMovement(fLX2);
    
    //Handle movement collisions to the right
    rightMovement(fLX3);
    rightMovement(fLX4);
    
    //Handle movement collisions upwards
    upMovement(fLY);
    upMovement(fLY4);
    
    //Handle movement collisions downwards
    downMovement(fLY2);
    downMovement(fLY3);
    
    //Move the player
    fPlayerX += iMoveX * iSpeedX;
    fPlayerY += iMoveY * iSpeedY;
  }
  
   public void collisionCalc(){
    //Calculate corners for hitbox checks
    iPlayerCornerX  = PApplet.parseInt(fPlayerX) - iPlayerSize/2;
    iPlayerCornerY  = PApplet.parseInt(fPlayerY) - iPlayerSize/2;
    iPlayerCornerX2 = PApplet.parseInt(fPlayerX) + iPlayerSize/2;
    iPlayerCornerY2 = PApplet.parseInt(fPlayerY) + iPlayerSize/2;
    
    //Check tiles adjacent to playerX
    fLX  = (PApplet.parseInt(iPlayerCornerY)>>iBitShift)*iMapSizeY + (PApplet.parseInt(iPlayerCornerX)>>iBitShift) - 1;
    fLX2 = (PApplet.parseInt(iPlayerCornerY2)>>iBitShift)*iMapSizeY + (PApplet.parseInt(iPlayerCornerX)>>iBitShift) - 1;
    fLX3 = (PApplet.parseInt(iPlayerCornerY)>>iBitShift)*iMapSizeY + (PApplet.parseInt(iPlayerCornerX2)>>iBitShift) + 1;
    fLX4 = (PApplet.parseInt(iPlayerCornerY2)>>iBitShift)*iMapSizeY + (PApplet.parseInt(iPlayerCornerX2)>>iBitShift) + 1;
    
    //Check tiles adjacent to playerY
    fLY  = (PApplet.parseInt(iPlayerCornerY)>>iBitShift)*iMapSizeY + (PApplet.parseInt(iPlayerCornerX)>>iBitShift) - iMapSizeY;
    fLY2 = (PApplet.parseInt(iPlayerCornerY2)>>iBitShift)*iMapSizeY + (PApplet.parseInt(iPlayerCornerX)>>iBitShift) + iMapSizeY;
    fLY3 = (PApplet.parseInt(iPlayerCornerY)>>iBitShift)*iMapSizeY + (PApplet.parseInt(iPlayerCornerX2)>>iBitShift) + iMapSizeY;
    fLY4 = (PApplet.parseInt(iPlayerCornerY2)>>iBitShift)*iMapSizeY + (PApplet.parseInt(iPlayerCornerX2)>>iBitShift) - iMapSizeY;
  }
  
   public void leftMovement(int i){ //Check movement collisions for going left
    if (mapCurrentLayout[i] == 1){
      if (iPlayerCornerX - iSpeedX < ((PApplet.parseInt(iPlayerCornerX)>>iBitShift)<<iBitShift)){
        fPlayerX = ((PApplet.parseInt(fPlayerX)>>iBitShift)<<iBitShift) + iSpeedX + iPlayerSize/2;
      }
    }
  }
  
   public void rightMovement(int i){ //Check movement collisions for going right
    if (mapCurrentLayout[i] == 1){
      if (iPlayerCornerX2 + iSpeedX >= ((PApplet.parseInt(iPlayerCornerX2)>>iBitShift)<<iBitShift) + iTileSize){
        fPlayerX = ((PApplet.parseInt(iPlayerCornerX2)>>iBitShift)<<iBitShift) + iTileSize - iSpeedX*2 - iPlayerSize/2;
      }
    }
  }
  
   public void upMovement(int i){ //Check movement collisions for going up
    if (mapCurrentLayout[i] == 1){
      if (iPlayerCornerY - iSpeedY < ((PApplet.parseInt(iPlayerCornerY)>>iBitShift)<<iBitShift)){
        fPlayerY = ((PApplet.parseInt(fPlayerY)>>iBitShift)<<iBitShift) + iSpeedY + iPlayerSize/2;
      }
    }
  }
  
   public void downMovement(int i){ //Check movement collisions for going down
    if (mapCurrentLayout[i] == 1){
      if (iPlayerCornerY2 + iSpeedY >= ((PApplet.parseInt(iPlayerCornerY2)>>iBitShift)<<iBitShift) + iTileSize){
        fPlayerY = ((PApplet.parseInt(iPlayerCornerY2)>>iBitShift)<<iBitShift) + iTileSize - iSpeedY*2 - iPlayerSize/2;
      }
    }
  }
}
//Public variables
public float f1DgrRad = 0.0174533f; //1 degree in radians

class Ray{

   public void drawRays(int count, int dens, float fOriginX, float fOriginY, float fOriginAngle, int bounces, String colour, int weight, boolean dangerous){
    //Variables
    int iDepth, iMX, iMY, iMP, iBounces, iRayCount, iDensity, iHorizontalBounce;
    float fRayY = 0, fRayX = 0, fRayAngle, fOffsetX = 0, fOffsetY = 0, fAngleOffset;
    
    //Calculate the amount of rays and the offset
    iRayCount = count;
    iDensity = dens;
    iRayCount = count * iDensity;
    fAngleOffset = f1DgrRad/iDensity; //Calculate offset in case of multiple rays
    fRayAngle = fOriginAngle - fAngleOffset * iRayCount; //Apply the offset calculated above
    
    //Set angle limits
    if (fRayAngle < 0){
      fRayAngle += 2*PI;
    }
    if (fRayAngle > 2*PI){
      fRayAngle -= 2*PI;
    }
    
    for (int rr = 0; rr < iRayCount; rr++){
      iBounces = bounces;
      
      //Horizontal collision check
      iDepth = 0;
      float fExtremeH = 9999999, fHorizontalX = fOriginX, fHorizontalY = fOriginY;
      float aTangent = -1/tan(fRayAngle);
      if (fRayAngle > PI){
        fRayY = ((PApplet.parseInt(fOriginY)>>iBitShift)<<iBitShift)-0.0001f; //bit shift to get nearest 64/32/16
        fRayX = (fOriginY - fRayY) * aTangent + fOriginX;
        fOffsetY = -iTileSize;
        fOffsetX = -fOffsetY * aTangent;
      }
      if (fRayAngle < PI){
        fRayY = ((PApplet.parseInt(fOriginY)>>iBitShift)<<iBitShift) + iTileSize; //bit shift to get nearest 64/32/16
        fRayX = (fOriginY - fRayY) * aTangent + fOriginX;
        fOffsetY =  iTileSize;
        fOffsetX = -fOffsetY * aTangent;
      }
      if (fRayAngle == 0 || fRayAngle == PI) { //In case the line has no angle or PI angle
        fRayX = fOriginX;
        fRayY = fOriginY;
        iDepth = iMapSizeX;
      }
      
      //Check for collisions with walls
      while (iDepth < iMapSizeX){
        iMX = PApplet.parseInt(fRayX)>>iBitShift;
        iMY = PApplet.parseInt(fRayY)>>iBitShift;
        iMP = iMY * iMapSizeX + iMX;
        if (iMP > 0 && iMP < iMapSizeX * iMapSizeY && mapCurrentLayout[iMP] == 1){
          fHorizontalX = fRayX;
          fHorizontalY = fRayY;
          fExtremeH = distanceToWall(fOriginX, fOriginY, fHorizontalX, fHorizontalY);
          iDepth = iMapSizeX; //Finish upon collision
        }
        else{ //Continue the line
          fRayX += fOffsetX;
          fRayY += fOffsetY;
          iDepth++;
        }
      }
      
      //Vertical collision check
      iDepth = 0;
      float fExtremeV = 9999999, fVerticalX = fOriginX, fVerticalY = fOriginY;
      float nTangent = -tan(fRayAngle);
      if (fRayAngle > PI/2 && fRayAngle < 3*PI/2){
        fRayX = ((PApplet.parseInt(fOriginX)>>iBitShift)<<iBitShift)-0.0001f; //bit shift to get nearest 64/32/16
        fRayY = (fOriginX - fRayX) * nTangent + fOriginY;
        fOffsetX = -iTileSize;
        fOffsetY = -fOffsetX * nTangent;
      }
      if (fRayAngle < PI/2 || fRayAngle > 3*PI/2){
        fRayX = ((PApplet.parseInt(fOriginX)>>iBitShift)<<iBitShift) + iTileSize; //bit shift to get nearest 64/32/16
        fRayY = (fOriginX - fRayX) * nTangent + fOriginY;
        fOffsetX =  iTileSize;
        fOffsetY = -fOffsetX * nTangent;
      }
      if (fRayAngle == 0 || fRayAngle == PI) { //In case the line has no angle or PI angle
        fRayX = fOriginX;
        fRayY = fOriginY;
        iDepth = iMapSizeY;
      }
      
      //Check for collisions with walls
      while (iDepth < iMapSizeY){
        iMX = PApplet.parseInt(fRayX)>>iBitShift;
        iMY = PApplet.parseInt(fRayY)>>iBitShift;
        iMP = iMY * iMapSizeX + iMX;
        if (iMP > 0 && iMP < iMapSizeX * iMapSizeY && mapCurrentLayout[iMP] == 1){
          fVerticalX = fRayX;
          fVerticalY = fRayY;
          fExtremeV = distanceToWall(fOriginX, fOriginY, fVerticalX, fVerticalY);
          iDepth = iMapSizeY; //Finish upon collision
        }
        else{ //Continue the line
          fRayX += fOffsetX;
          fRayY += fOffsetY;
          iDepth++;
        }
      }
      
      //Check which line is shorter, horizontal or vertical. Then, pick the values of that line for the Ray
      if (fExtremeV < fExtremeH){
        fRayX = fVerticalX;
        fRayY = fVerticalY;
        iHorizontalBounce = 0;
      }
      else{
        fRayX = fHorizontalX;
        fRayY = fHorizontalY;
        iHorizontalBounce = 1;
      }
      
      //Pick a colour for the line
      switch(colour){
        case "LightGreen":
          stroke(50, 255, 50);
          break;
        case "Red":
          if (bPlayerAlive){stroke(255, 0, 0, 0);}
          else{stroke(255, 0, 0, 255);}
          break;
        case "LightRed":
          stroke(255, 0, 0, 0);
          break;
        case "Yellow":
          stroke(255, 255, 0);
          break;
        case "Purple":
          stroke(255, 0, 255);
          break;
        case "White":
          stroke(200);
          break;
        case "Blue":
          stroke(0, 0, 255);
          break;
      }
      
      //Draw a visible line to represent the ray
      strokeWeight(weight);
      line(fOriginX, fOriginY, fRayX, fRayY);
      
      
      //Check bounce angle
      float fBounceAngle = 0;
      switch(iHorizontalBounce){
        case 1:
          if (fRayAngle < PI/2){fBounceAngle = PI/2 - fRayAngle; fBounceAngle = fBounceAngle + PI*1.5f;}
          if (fRayAngle > PI/2 && fRayAngle < PI){fBounceAngle = fRayAngle - PI/2; fBounceAngle = PI*1.5f - fBounceAngle;}
          if (fRayAngle > PI && fRayAngle < PI*1.5f){fBounceAngle = PI/2 - (fRayAngle - PI); fBounceAngle = fBounceAngle - PI*1.5f;}
          if (fRayAngle > PI*1.5f && fRayAngle < PI*2){fBounceAngle = fRayAngle - PI*1.5f; fBounceAngle = PI*2.5f - fBounceAngle;}
          break;
        case 0:
          if (fRayAngle < PI/2){fBounceAngle = fRayAngle; fBounceAngle = PI - fBounceAngle;}
          if (fRayAngle > PI/2 && fRayAngle < PI){fBounceAngle = PI/2 - (fRayAngle - PI/2); fBounceAngle = fBounceAngle - PI*2;}
          if (fRayAngle > PI && fRayAngle < PI*1.5f){fBounceAngle = fRayAngle - PI; fBounceAngle = 2*PI - fBounceAngle;}
          if (fRayAngle > PI*1.5f && fRayAngle < PI*2){fBounceAngle = PI/2 - (fRayAngle - PI*1.5f); fBounceAngle = PI + fBounceAngle;}
          break;
      }
      
      //Bounce a new ray if there are any bounces left
      if (iBounces > 0){
        iBounces--;
        drawRays(1, 1, fRayX, fRayY, fBounceAngle, iBounces, colour, weight, dangerous);
      }
      
      //Increase the angle for the next line
      fRayAngle += fAngleOffset;
      
      //Reset angle limit
      if (fRayAngle < 0){
        fRayAngle += 2*PI;
      }
      if (fRayAngle > 2*PI){
        fRayAngle -= 2*PI;
      }
      
      //Convert the points of the ray into a line equation
      float fDiffX = fOriginX - fRayX;
      float fDiffY = fOriginY - fRayY;
      float fEqM = fDiffY/fDiffX;
      float fEqC = fEqM * fRayX - fRayY;
      fEqC *= -1;
      
      //Reset enemy vulnerability status
      for (int ii = 0; ii < iEnemyCount; ii++){
        Enemy currentEnemy = enemies.get(ii);
        currentEnemy.bVulnerable = false;
      }
      
      //Check for ray overlap with enemies
      for (float i = fOriginX; i < fRayX; i++){
        float fCoordY = fEqM * i + fEqC;
        if (colour == "Red" && P1.checkPixel(i, fCoordY) && bPlayerAlive == true){
          bPlayerAlive = false; //Kill the player if an enemy has LoS
        }
        if (colour == "LightRed" && P1.checkPixel(i, fCoordY) && iEnemiesStillAlive < 4){
          stroke(255, 0, 0);
          point(i, fCoordY); //Draw a radar in case there are less then 4 enemies left
        }
        for (int ii = 0; ii < iEnemyCount; ii++){
          Enemy currentEnemy = enemies.get(ii);
          if ((colour == "White" || colour == "LightGreen") && currentEnemy.checkPixel(i, fCoordY) && currentEnemy.bAlive == true){
            stroke(255, 0, 0);
            point(i, fCoordY); //Colour the pixel red if your vision overlaps with the enemy
            if (dangerous){currentEnemy.bVulnerable = true;} //Make enemies you aim at vulnerable
            currentEnemy.checkDeath();
          }
        }
      }
      for (float i = fOriginX; i >= fRayX; i--){
        float fCoordY = fEqM * i + fEqC;
        if (colour == "Red" && P1.checkPixel(i, fCoordY) && bPlayerAlive == true){
          bPlayerAlive = false; //Kill the player if an enemy has LoS
        }
        if (colour == "LightRed" && P1.checkPixel(i, fCoordY) && iEnemiesStillAlive < 4){
          stroke(255, 0, 0);
          point(i, fCoordY); //Draw a radar in case there are less then 4 enemies left
        }
        for (int ii = 0; ii < iEnemyCount; ii++){
          Enemy currentEnemy = enemies.get(ii);
          if ((colour == "White" || colour == "LightGreen") && currentEnemy.checkPixel(i, fCoordY) && currentEnemy.bAlive == true){
            stroke(255, 0, 0);
            point(i, fCoordY); //Colour the pixel red if your vision overlaps with the enemy
            if (dangerous){currentEnemy.bVulnerable = true;} //Make enemies you aim at vulnerable
            currentEnemy.checkDeath();
          }
        }
      }
      for (float i = fOriginY; i < fRayY; i++){
        float fCoordX = (i/fEqM) - (fEqC/fEqM);
        if (colour == "Red" && P1.checkPixel(fCoordX, i) && bPlayerAlive == true){
          bPlayerAlive = false; //Kill the player if an enemy has LoS
        }
        if (colour == "LightRed" && P1.checkPixel(fCoordX, i) && iEnemiesStillAlive < 4){
          stroke(255, 0, 0);
          point(fCoordX, i); //Draw a radar in case there are less then 4 enemies left
        }
        for (int ii = 0; ii < iEnemyCount; ii++){
          Enemy currentEnemy = enemies.get(ii);
          if ((colour == "White" || colour == "LightGreen") && currentEnemy.checkPixel(fCoordX, i) && currentEnemy.bAlive == true){
            stroke(255, 0, 0);
            point(fCoordX, i); //Colour the pixel red if your vision overlaps with the enemy
            if (dangerous){currentEnemy.bVulnerable = true;} //Make enemies you aim at vulnerable
            currentEnemy.checkDeath();
          }
        }
      }
      for (float i = fOriginY; i >= fRayY; i--){
        float fCoordX = (i/fEqM) - (fEqC/fEqM);
        if (colour == "Red" && P1.checkPixel(fCoordX, i) && bPlayerAlive == true){
          bPlayerAlive = false; //Kill the player if an enemy has LoS
        }
        if (colour == "LightRed" && P1.checkPixel(fCoordX, i) && iEnemiesStillAlive < 4){
          stroke(255, 0, 0);
          point(fCoordX, i); //Draw a radar in case there are less then 4 enemies left
        }
        for (int ii = 0; ii < iEnemyCount; ii++){
          Enemy currentEnemy = enemies.get(ii);
          if ((colour == "White" || colour == "LightGreen") && currentEnemy.checkPixel(fCoordX, i) && currentEnemy.bAlive == true){
            stroke(255, 0, 0);
            point(fCoordX, i); //Colour the pixel red if your vision overlaps with the enemy
            if (dangerous){currentEnemy.bVulnerable = true;} //Make enemies you aim at vulnerable
            currentEnemy.checkDeath();
          }
        }
      }
    }
  }
}


  public void settings() { size(640, 640); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "RayCaster" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
